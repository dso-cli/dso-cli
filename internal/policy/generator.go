package policy

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// GenerateOPAPolicy generates an OPA/Rego policy based on detected patterns
func GenerateOPAPolicy(projectPath string) (string, error) {
	// Detect file types in the project
	_ = detectSecretsPatterns(projectPath) // hasSecrets - used for future policy generation
	hasDocker := detectFileType(projectPath, "Dockerfile", "docker-compose.yml")
	hasTerraform := detectFileType(projectPath, "*.tf")
	hasK8s := detectFileType(projectPath, "*.yaml", "*.yml")

	policy := `package dso.security

# Security policy generated by DSO
# Do not modify manually - regenerate with: dso policy --type opa

import future.keywords.if
import future.keywords.in

# Rule: No secrets in code
deny_secrets[msg] {
    file := input.files[_]
    contains(file.content, "AKIA")
    msg := sprintf("AWS secret detected in %v", [file.path])
}

deny_secrets[msg] {
    file := input.files[_]
    contains(file.content, "sk_live_")
    msg := sprintf("Stripe API key detected in %v", [file.path])
}

deny_secrets[msg] {
    file := input.files[_]
    contains(file.content, "ghp_")
    msg := sprintf("GitHub token detected in %v", [file.path])
}

# Rule: Dockerfiles must use non-root images
deny_docker_root[msg] if hasDocker {
    file := input.files[_]
    startswith(file.path, "Dockerfile")
    contains(file.content, "USER root")
    not contains(file.content, "USER ")
    msg := sprintf("Dockerfile %v should use a non-root user", [file.path])
}

# Rule: Terraform - no public resources without restrictions
deny_public_resources[msg] if hasTerraform {
    file := input.files[_]
    endswith(file.path, ".tf")
    contains(file.content, "aws_s3_bucket")
    contains(file.content, "public_access_block")
    msg := sprintf("Potentially public S3 bucket in %v", [file.path])
}

# Rule: Kubernetes - no secrets in plain text
deny_k8s_secrets[msg] if hasK8s {
    file := input.files[_]
    endswith(file.path, ".yaml") or endswith(file.path, ".yml")
    contains(file.content, "kind: Secret")
    contains(file.content, "password:")
    not contains(file.content, "type: Opaque")
    msg := sprintf("Potentially plain text Kubernetes secret in %v", [file.path])
}

# Main rule
deny[msg] {
    msg := deny_secrets[_]
}

deny[msg] if hasDocker {
    msg := deny_docker_root[_]
}

deny[msg] if hasTerraform {
    msg := deny_public_resources[_]
}

deny[msg] if hasK8s {
    msg := deny_k8s_secrets[_]
}
`

	// Replace dynamic conditions
	policy = strings.ReplaceAll(policy, "if hasDocker", fmt.Sprintf("if %v", hasDocker))
	policy = strings.ReplaceAll(policy, "if hasTerraform", fmt.Sprintf("if %v", hasTerraform))
	policy = strings.ReplaceAll(policy, "if hasK8s", fmt.Sprintf("if %v", hasK8s))

	return policy, nil
}

// GenerateCODEOWNERS generates a CODEOWNERS file based on security patterns
func GenerateCODEOWNERS(projectPath string) (string, error) {
	codeowners := `# CODEOWNERS generated by DSO
# Sensitive files require security review

# Secrets et configuration
/.env*
/.env.*
/**/*secret*
/**/*key*
/**/*credential*

# Infrastructure as Code
/**/*.tf
/**/*.tfvars
/**/Dockerfile*
/**/docker-compose*.yml
/**/*.yaml
/**/*.yml

# Scripts de dÃ©ploiement
/**/deploy.sh
/**/deploy/*
/**/scripts/*.sh

# Kubernetes configuration
/**/k8s/**
/**/kubernetes/**

# CI/CD configuration
/.github/workflows/**
/.gitlab-ci.yml
/**/Jenkinsfile

# All security files
/.dso/**
/security/**
`

	return codeowners, nil
}

// Utility functions
func detectFileType(path string, patterns ...string) bool {
	for _, pattern := range patterns {
		matches, _ := filepath.Glob(filepath.Join(path, pattern))
		if len(matches) > 0 {
			return true
		}
	}
	return false
}

func detectSecretsPatterns(path string) bool {
	secretPatterns := []string{
		".env",
		"secret",
		"key",
		"credential",
		"password",
	}

	err := filepath.Walk(path, func(p string, info os.FileInfo, err error) error {
		if err != nil {
			return nil
		}
		if info.IsDir() {
			return nil
		}
		base := strings.ToLower(info.Name())
		for _, pattern := range secretPatterns {
			if strings.Contains(base, pattern) {
				return fmt.Errorf("found")
			}
		}
		return nil
	})

	return err != nil && err.Error() == "found"
}
